import {
  If,
  Node_default,
  abs,
  addNodeClass,
  addNodeElement,
  bool,
  dot,
  float,
  floor,
  int,
  max,
  min,
  mul,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeProxy,
  sqrt,
  sub,
  tslFn,
  uint,
  uvec3,
  vec2,
  vec3,
  vec4
} from "./chunk-NDKYRTLU.js";
import "./chunk-AB3AYXXB.js";

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(nodeType, name = null, varying = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying;
    this.isPropertyNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
};
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var alphaT = nodeImmutable(PropertyNode, "float", "AlphaT");
var anisotropy = nodeImmutable(PropertyNode, "float", "Anisotropy");
var anisotropyT = nodeImmutable(PropertyNode, "vec3", "AnisotropyT");
var anisotropyB = nodeImmutable(PropertyNode, "vec3", "AnisotropyB");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var specularF90 = nodeImmutable(PropertyNode, "float", "SpecularF90");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashSize");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
var pointWidth = nodeImmutable(PropertyNode, "float", "pointWidth");
var ior = nodeImmutable(PropertyNode, "float", "IOR");
var transmission = nodeImmutable(PropertyNode, "float", "Transmission");
var thickness = nodeImmutable(PropertyNode, "float", "Thickness");
var attenuationDistance = nodeImmutable(PropertyNode, "float", "AttenuationDistance");
var attenuationColor = nodeImmutable(PropertyNode, "color", "AttenuationColor");
var dispersion = nodeImmutable(PropertyNode, "float", "Dispersion");
addNodeClass("PropertyNode", PropertyNode);

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  analyze(builder) {
    this.node.build(builder);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output2) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
};
var context = nodeProxy(ContextNode);
var label = (node, name) => context(node, { label: name });
addNodeElement("context", context);
addNodeElement("label", label);
addNodeClass("ContextNode", ContextNode);

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { ifNode, elseNode } = this;
    const needsOutput = output2 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = context(
      this.condNode
      /*, context*/
    ).build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = context(ifNode, context2).build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = context(elseNode, context2).build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output2);
  }
};
var cond = nodeProxy(CondNode);
addNodeElement("cond", cond);
addNodeClass("CondNode", CondNode);

// node_modules/three/examples/jsm/nodes/utils/FunctionOverloadingNode.js
var FunctionOverloadingNode = class extends Node_default {
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFnCall = null;
  }
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type;
  }
  setup(builder) {
    const params = this.parametersNodes;
    let candidateFnCall = this._candidateFnCall;
    if (candidateFnCall === null) {
      let candidateFn = null;
      let candidateScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let score = 0;
          for (let i = 0; i < params.length; i++) {
            const param = params[i];
            const input = inputs[i];
            if (param.getNodeType(builder) === input.type) {
              score++;
            } else {
              score = 0;
            }
          }
          if (score > candidateScore) {
            candidateFn = functionNode;
            candidateScore = score;
          }
        }
      }
      this._candidateFnCall = candidateFnCall = candidateFn(...params);
    }
    return candidateFnCall;
  }
};
var overloadingBaseFn = nodeProxy(FunctionOverloadingNode);
var overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
addNodeClass("FunctionOverloadingNode", FunctionOverloadingNode);

// node_modules/three/examples/jsm/nodes/code/ExpressionNode.js
var ExpressionNode = class extends Node_default {
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet);
    } else {
      return builder.format(`( ${snippet} )`, type, output2);
    }
  }
};
var expression = nodeProxy(ExpressionNode);
addNodeClass("ExpressionNode", ExpressionNode);

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet);
    }
    return this.outputNode.build(builder);
  }
};
var bypass = nodeProxy(BypassNode);
addNodeElement("bypass", bypass);
addNodeClass("BypassNode", BypassNode);

// node_modules/three/examples/jsm/nodes/utils/LoopNode.js
var LoopNode = class extends Node_default {
  constructor(params = []) {
    super();
    this.params = params;
  }
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt() + index);
  }
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0)
      return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const param = this.params[i];
      const name = param.isNode !== true && param.name || this.getVarName(i);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    properties.returnsNode = this.params[this.params.length - 1](inputs, builder.addStack(), builder);
    properties.stackNode = builder.removeStack();
    return properties;
  }
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  setup(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const contextData = { tempWrite: false };
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      let start = null, end = null, name = null, type = null, condition = null, update = null;
      if (param.isNode) {
        type = "int";
        name = this.getVarName(i);
        start = "0";
        end = param.build(builder, type);
        condition = "<";
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update = param.update;
        if (typeof start === "number")
          start = start.toString();
        else if (start && start.isNode)
          start = start.build(builder, type);
        if (typeof end === "number")
          end = end.toString();
        else if (end && end.isNode)
          end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      const internalParam = { start, end, condition };
      const startSnippet = internalParam.start;
      const endSnippet = internalParam.end;
      let declarationSnippet = "";
      let conditionalSnippet = "";
      let updateSnippet = "";
      if (!update) {
        if (type === "int" || type === "uint") {
          if (condition.includes("<"))
            update = "++";
          else
            update = "--";
        } else {
          if (condition.includes("<"))
            update = "+= 1.";
          else
            update = "-= 1.";
        }
      }
      declarationSnippet += builder.getVar(type, name) + " = " + startSnippet;
      conditionalSnippet += name + " " + condition + " " + endSnippet;
      updateSnippet += name + " " + update;
      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + forSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = context(stackNode, contextData).build(builder, "void");
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int"))).append();
addNodeElement("loop", (returns, ...params) => bypass(returns, loop(...params)));
addNodeClass("LoopNode", LoopNode);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js
var mx_select = tslFn(([b_immutable, t_immutable, f_immutable]) => {
  const f = float(f_immutable).toVar();
  const t = float(t_immutable).toVar();
  const b = bool(b_immutable).toVar();
  return cond(b, t, f);
});
var mx_negate_if = tslFn(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float(val_immutable).toVar();
  return cond(b, val.negate(), val);
});
var mx_floor = tslFn(([x_immutable]) => {
  const x = float(x_immutable).toVar();
  return int(floor(x));
});
var mx_floorfrac = tslFn(([x_immutable, i]) => {
  const x = float(x_immutable).toVar();
  i.assign(mx_floor(x));
  return x.sub(float(i));
});
var mx_bilerp_0 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
});
var mx_bilerp_1 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
});
var mx_bilerp = overloadingFn([mx_bilerp_0, mx_bilerp_1]);
var mx_trilerp_0 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = float(v7_immutable).toVar();
  const v6 = float(v6_immutable).toVar();
  const v5 = float(v5_immutable).toVar();
  const v4 = float(v4_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
});
var mx_trilerp_1 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = vec3(v7_immutable).toVar();
  const v6 = vec3(v6_immutable).toVar();
  const v5 = vec3(v5_immutable).toVar();
  const v4 = vec3(v4_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
});
var mx_trilerp = overloadingFn([mx_trilerp_0, mx_trilerp_1]);
var mx_gradient_float_0 = tslFn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash = uint(hash_immutable).toVar();
  const h = uint(hash.bitAnd(uint(7))).toVar();
  const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();
  const v = float(mul(2, mx_select(h.lessThan(uint(4)), y, x))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
});
var mx_gradient_float_1 = tslFn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash = uint(hash_immutable).toVar();
  const h = uint(hash.bitAnd(uint(15))).toVar();
  const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();
  const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
});
var mx_gradient_float = overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
var mx_gradient_vec3_0 = tslFn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
});
var mx_gradient_vec3_1 = tslFn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
});
var mx_gradient_vec3 = overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
var mx_gradient_scale2d_0 = tslFn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.6616, v);
});
var mx_gradient_scale3d_0 = tslFn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.982, v);
});
var mx_gradient_scale2d_1 = tslFn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.6616, v);
});
var mx_gradient_scale2d = overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
var mx_gradient_scale3d_1 = tslFn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.982, v);
});
var mx_gradient_scale3d = overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
var mx_rotl32 = tslFn(([x_immutable, k_immutable]) => {
  const k = int(k_immutable).toVar();
  const x = uint(x_immutable).toVar();
  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
});
var mx_bjmix = tslFn(([a, b, c]) => {
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(4)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(6)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(8)));
  b.addAssign(a);
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(16)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(19)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(4)));
  b.addAssign(a);
});
var mx_bjfinal = tslFn(([a_immutable, b_immutable, c_immutable]) => {
  const c = uint(c_immutable).toVar();
  const b = uint(b_immutable).toVar();
  const a = uint(a_immutable).toVar();
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(14)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(11)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(25)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(16)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(4)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(14)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(24)));
  return c;
});
var mx_bits_to_01 = tslFn(([bits_immutable]) => {
  const bits = uint(bits_immutable).toVar();
  return float(bits).div(float(uint(int(4294967295))));
});
var mx_fade = tslFn(([t_immutable]) => {
  const t = float(t_immutable).toVar();
  return t.mul(t.mul(t.mul(t.mul(t.mul(6).sub(15)).add(10))));
});
var mx_hash_int_0 = tslFn(([x_immutable]) => {
  const x = int(x_immutable).toVar();
  const len = uint(uint(1)).toVar();
  const seed = uint(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13)))).toVar();
  return mx_bjfinal(seed.add(uint(x)), seed, seed);
});
var mx_hash_int_1 = tslFn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(2)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_2 = tslFn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(3)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_3 = tslFn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(4)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_4 = tslFn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
  const yy = int(yy_immutable).toVar();
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(5)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  b.addAssign(uint(yy));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int = overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
var mx_hash_vec3_0 = tslFn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
});
var mx_hash_vec3_1 = tslFn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y, z)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
});
var mx_hash_vec3 = overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
var mx_perlin_noise_float_0 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
});
var mx_perlin_noise_float_1 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
});
var mx_perlin_noise_float = overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
var mx_perlin_noise_vec3_0 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
});
var mx_perlin_noise_vec3_1 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
});
var mx_perlin_noise_vec3 = overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
var mx_cell_noise_float_0 = tslFn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
});
var mx_cell_noise_float_1 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
});
var mx_cell_noise_float_2 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
});
var mx_cell_noise_float_3 = tslFn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
});
var mx_cell_noise_float = overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
var mx_cell_noise_vec3_0 = tslFn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
});
var mx_cell_noise_vec3_1 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
});
var mx_cell_noise_vec3_2 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
});
var mx_cell_noise_vec3_3 = tslFn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
});
var mx_cell_noise_vec3 = overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
var mx_fractal_noise_float = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = float(0).toVar();
  const amplitude = float(1).toVar();
  loop({ start: int(0), end: octaves }, ({ i }) => {
    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
});
var mx_fractal_noise_vec3 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = vec3(0).toVar();
  const amplitude = float(1).toVar();
  loop({ start: int(0), end: octaves }, ({ i }) => {
    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
});
var mx_fractal_noise_vec2 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish), mx_fractal_noise_float(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
});
var mx_fractal_noise_vec4 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const c = vec3(mx_fractal_noise_vec3(p, octaves, lacunarity, diminish)).toVar();
  const f = float(mx_fractal_noise_float(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
  return vec4(c, f);
});
var mx_worley_distance_0 = tslFn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();
  const off = vec2(tmp.x, tmp.y).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
  const diff = vec2(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y));
  });
  If(metric.equal(int(3)), () => {
    return max(abs(diff.x), abs(diff.y));
  });
  return dot(diff, diff);
});
var mx_worley_distance_1 = tslFn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const zoff = int(zoff_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
  const diff = vec3(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y).add(abs(diff.z)));
  });
  If(metric.equal(int(3)), () => {
    return max(max(abs(diff.x), abs(diff.y)), abs(diff.z));
  });
  return dot(diff, diff);
});
var mx_worley_distance = overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
var mx_worley_noise_float_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = float(1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      sqdist.assign(min(sqdist, dist));
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec2_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).elseif(dist.lessThan(sqdist.y), () => {
        sqdist.y.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec3_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).elseif(dist.lessThan(sqdist.y), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(dist);
      }).elseif(dist.lessThan(sqdist.z), () => {
        sqdist.z.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_float_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = float(1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        sqdist.assign(min(sqdist, dist));
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_float = overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
var mx_worley_noise_vec2_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).elseif(dist.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec2 = overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
var mx_worley_noise_vec3_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).elseif(dist.lessThan(sqdist.y), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist);
        }).elseif(dist.lessThan(sqdist.z), () => {
          sqdist.z.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec3 = overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
mx_select.setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
});
mx_negate_if.setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
});
mx_floor.setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
});
mx_bilerp_0.setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
mx_bilerp_1.setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
mx_trilerp_0.setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
mx_trilerp_1.setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
mx_gradient_float_0.setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
mx_gradient_float_1.setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
mx_gradient_vec3_0.setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
mx_gradient_vec3_1.setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
mx_gradient_scale2d_0.setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
mx_gradient_scale3d_0.setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
mx_gradient_scale2d_1.setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
mx_gradient_scale3d_1.setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
mx_rotl32.setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
});
mx_bjfinal.setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
});
mx_bits_to_01.setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
});
mx_fade.setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
});
mx_hash_int_0.setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
});
mx_hash_int_1.setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
mx_hash_int_2.setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
mx_hash_int_3.setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
});
mx_hash_int_4.setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
});
mx_hash_vec3_0.setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
mx_hash_vec3_1.setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
mx_perlin_noise_float_0.setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_perlin_noise_float_1.setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_perlin_noise_vec3_0.setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_perlin_noise_vec3_1.setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_float_0.setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
});
mx_cell_noise_float_1.setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_cell_noise_float_2.setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_float_3.setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
mx_cell_noise_vec3_0.setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
});
mx_cell_noise_vec3_1.setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_cell_noise_vec3_2.setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_vec3_3.setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
mx_fractal_noise_float.setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec3.setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec2.setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec4.setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_worley_distance_0.setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_distance_1.setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_float_0.setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec2_0.setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec3_0.setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_float_1.setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec2_1.setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec3_1.setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
export {
  mx_bilerp,
  mx_bits_to_01,
  mx_bjfinal,
  mx_bjmix,
  mx_cell_noise_float,
  mx_cell_noise_vec3,
  mx_fade,
  mx_floor,
  mx_floorfrac,
  mx_fractal_noise_float,
  mx_fractal_noise_vec2,
  mx_fractal_noise_vec3,
  mx_fractal_noise_vec4,
  mx_gradient_float,
  mx_gradient_scale2d,
  mx_gradient_scale3d,
  mx_gradient_vec3,
  mx_hash_int,
  mx_hash_vec3,
  mx_negate_if,
  mx_perlin_noise_float,
  mx_perlin_noise_vec3,
  mx_rotl32,
  mx_select,
  mx_trilerp,
  mx_worley_distance,
  mx_worley_noise_float,
  mx_worley_noise_vec2,
  mx_worley_noise_vec3
};
//# sourceMappingURL=three_examples_jsm_nodes_materialx_lib_mx_noise__js.js.map
